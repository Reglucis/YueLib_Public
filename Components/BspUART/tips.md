实现一种用于进行消息发送且类似于池的数据结构，大概思想

当前存在问题：
	1. 需要使用 printf 函数实时调试，让单片机将数据发送至上位机。(已解决)
		重定向 putchar , 并使用 microlib 。
	2. 上述解决方法是最常见的解决方法，但问题是由于阻塞发送，串口发送信息时，可能因波特率过低或消息过于密集，导致占用大量 CPU 时间。(已解决)
		建立一个静态缓冲区，每次发送消息都申请一块堆内存, 经 vsprintf 处理后, 使用 DMA 整体发送。
	3. 虽然保持了对 printf 的支持，但由于使用了新的发送逻辑, 导致原有的 printf 极可能发送失败, 在使用开源库时常常出现打印出错的问题。
	4. 每次发送都要进行申请与释放操作，极为浪费时间。短时间内大量并发的小信息发送任务会使效率降到奇低，并且 DMA 的优势完全无法发挥出来。
		分析问题：
			碎片消息的大量并发在原有逻辑下会被分配到不同堆地址上，内存空间并不连续；但对于消息本身来说，其逻辑上并不分散。
			完全可以使用一个大型的缓冲区将小的消息变成地址连续的长消息，再由 DMA 统一发送。此时，putchar 也可以视作为每次发送一个字符信息的信息源。
		解决方法：
			引入消息池概念：
				申请一块极大内存的缓冲工作区，该区被人为划分为三个逻辑块。(约定单次信息量不超过 100 byte)
				逻辑块 1 : 空闲工作区， 该区内消息已发送但并未清空。
				逻辑块 2 : 缓冲工作区，该区内消息等待发送。
				逻辑块 3 : 临界缓冲区，该区空间未使用。当写入指针指向该块后会尝试将写入指针复位至池头。
					当写入指针指向最后 100 byte 的时候，如果空闲工作区大小大于临界缓冲区的大小，写指针复位；
					若空闲工作区无法复位，则会创建一块新的工作区，并挂接在工作区 FIFO 中。





